---
title: 3.1. PID Namespace
category: 하나씩 익히는 Container
date: 2020-04-12T12:00:00Z
lastmod: 2020-04-12T12:00:00Z
comment: true
adsense: true
---

{% highlight console %}
# Run a nginx container and exec bash in the nginx container
(host)# docker run -d --name nginx nginx:1.16.1
(host)# docker exec -it nginx bash

# Check process in the nginx container
(nginx)# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Apr10 ?        00:00:00 nginx: master process nginx -g daemon off;
nginx        6     1  0 Apr10 ?        00:00:00 nginx: worker process
{% endhighlight %}
<figure>
<figcaption class="caption">[Shell 1] nginx Container Process</figcaption>
</figure>

{% highlight console %}
# Run a httpd container and exec bash in the httpd container
(host)# docker run -d --name httpd httpd:2.4.43
(host)# docker exec -it httpd bash

# Check process in the httpd container
(httpd)# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Apr10 ?        00:00:05 httpd -DFOREGROUND
daemon       7     1  0 Apr10 ?        00:00:00 httpd -DFOREGROUND
daemon       8     1  0 Apr10 ?        00:00:00 httpd -DFOREGROUND
daemon       9     1  0 Apr10 ?        00:00:00 httpd -DFOREGROUND
{% endhighlight %}
<figure>
<figcaption class="caption">[Shell 2] httpd Container Process</figcaption>
</figure>

{% highlight console %}
# Check process in the host
(host)# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
...
root     20997 20969  0 Apr10 ?        00:00:00 nginx: master process nginx -g daemon off;
systemd+ 21042 20997  0 Apr10 ?        00:00:00 nginx: worker process
...
root     25759 25739  0 Apr10 ?        00:00:05 httpd -DFOREGROUND
daemon   25816 25759  0 Apr10 ?        00:00:00 httpd -DFOREGROUND
daemon   25817 25759  0 Apr10 ?        00:00:00 httpd -DFOREGROUND
daemon   25818 25759  0 Apr10 ?        00:00:00 httpd -DFOREGROUND
...
{% endhighlight %}
<figure>
<figcaption class="caption">[Shell 3] Host Process</figcaption>
</figure>

[Shell 1]은 nginx Container 내부에서 본 Process를 나타내고 있고 [Shell 2]는 httpd Container 내부에서 본 Process를 나타내고 있다. 마지막으로 [Shell 3]은 Host에서 본 Process를 나타내고 있다. NGNIX Container와 httpd Container는 서로의 Process를 확인할 수 없지만, Host는 두 Container의 Proces를 모두 확인할 수 있다. 이러한 현상을 이해하기 위해서는 PID Namespace의 특징을 이해해야 한다.

![[그림 1] PID Namespace]({{site.baseurl}}/images/onebyone_container/PID_Namespace/PID_Namespace.PNG)

PID Namespace는 의미 그대로 PID를 격리하는 역활을 수행하는 Namespace이다. [그림 1]은 PID Namespace와 Process Tree의 관계를 나타내고 있다. [그림 1]에는 A,B,C,D 4개의 PID Namespace가 존재한다. PID Namespace는 Namespace중에서 유일하게 **"계층"**을 갖는 Namespace이다. 가장 높은 PID Namespace는 **"Init PID Namespace"**라고 명칭한다. [그림 1]의 왼쪽 Tree는 PID Namespace의 계층을 나타내고 있다. A Namespace는 Init Namespace이며 자식 Namespace로 B, C Namespace를 갖고 있다.

각 Namespace에서 Process Tree의 가장 높이 위치하는 Proess는 **"Init Process"**라고 명칭한다. [그림 1]에서 A Process는 A Namespace의 Init Process이고, D Process는 C Namespace의 Init Process이다. 각 PID Namespace가 볼 수 있는 Process는 PID Namespace의 Init Process의 하위 Process만 접근할 수 있다. [그림 1]에서 C Namespace의 Init Process는 D Process이기 때문에 C Namespace는 D Process의 하위 Process에만 접근할 수 있다. 이러한 특징 때문에 형제 관계를 갖는 PID Namespace들은 서로의 Proces를 접근할 수 없다. [그림 1]에서 B Namespace와 C Namespace는 서로의 Process를 접근할 수 없다.

동일한 Process라도 각 Namespace마다 다른 PID를 갖는다. 또한 각 Namespace를 Init Procesess는 해당 Namespace에서 1번 PID를 갖는다. [그림 1]에서 E Process는 A Namespace에서는 5번 PID로 보이지만 B Namespace에서는 6번 PID로 보인다. B Process는 B Namespace의 Init Process이기 때문에 1번 B Namespace에서는 1번 PID로 보인다.

일반적으로 각 Container는 자신의 전용 PID Namespace안에서 동작한다. Host의 Process 또한 Init PID Namespace에서 동작한다. 따라서 A Namespace를 Host PID Namespace로, B Namespace를 nginx PID Namespace로, C Namespace를 httpd PID Namespace로 Mapping 한다면 각 Container에서 보이는 Process들의 현상을 이해할 수 있게 된다.

{% highlight console %}
# Run bash and run sleep in the bash
(host)# bash -c "(bash -c 'sleep 60')" &
(host)# ps -ef
root         1     0  0 Apr22 ?        00:00:03 /sbin/init
...
root     29756 28207  0 22:06 pts/24   00:00:00 bash -c (bash -c 'sleep 60')
root     29758 29756  0 22:06 pts/24   00:00:00 sleep 60
root     29764 28207  0 22:06 pts/24   00:00:00 ps -ef

# Kill bash process and check the ppid of sleep process
(host)# kill -9 29756
(host)# ps -ef
root         1     0  0 Apr22 ?        00:00:03 /sbin/init
...
root     29758     1  0 22:06 pts/24   00:00:00 sleep 60
root     29779 28207  0 22:07 pts/24   00:00:00 ps -ef

# After 60s there is no sleep process info
(host)# ps -ef
root         1     0  0 Apr22 ?        00:00:03 /sbin/init
...
root     29779 28207  0 22:07 pts/24   00:00:00 ps -ef
{% endhighlight %}
<figure>
<figcaption class="caption">[Shell 4] Host Orphan Process </figcaption>
</figure>

PID Namespace와 함께 반드시 고려되어야 할 부분은 Orphan Process와 Zombie Process이다. Linux에서 Orphan Proces는 PID 1번인 Init Process에 의해서 거두어 진다는 특징을 갖고 있다. [Shell 4]는 Host에서 Orphan Process 생성 및 상태를 확인하는 과정을 나타내고 있다. [Shell 4]에서 sleep Process는 Bash Process를 Parent로 갖는 Process인데 Bash Process가 죽은 다음 sleep Process의 Parent는 init Process가 되는것을 확인할 수 있다. 60초 후에 sleep이 죽은 다음 /sbin/init Process는 Child Process인 sleep Process의 정보를 정리하여 sleep Process가 Zombie Process가 되는것을 방지한다.

{% highlight console %}
# Run a ubuntu container with sleep init process and exec bash in the ubuntu container
(host)# docker run --rm -d --name ubuntu ubuntu sleep infinity
(host)# docker exec -it ubuntu bash

# Run bash and run sleep in the bash
(ubuntu)# bash -c "(bash -c 'sleep 60')" &
(ubuntu)# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 13:33 ?        00:00:00 sleep infinity
root         6     0  1 13:45 pts/0    00:00:00 bash
root        15     6  0 13:46 pts/0    00:00:00 bash -c (bash -c 'sleep 60')
root        16    15  0 13:46 pts/0    00:00:00 sleep 60
root        17     6  0 13:46 pts/0    00:00:00 ps -ef

# Kill bash process to change ppid of sleep 60 process to sleep infinity process
(ubuntu)# kill -9 15
(ubuntu)# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 13:33 ?        00:00:00 sleep infinity
root         6     0  0 13:45 pts/0    00:00:00 bash
root        16     1  0 13:46 pts/0    00:00:00 sleep 60
root        18     6  0 13:46 pts/0    00:00:00 ps -ef

# After 60s sleep 60 process to be zombie process.
(ubuntu)# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 13:33 ?        00:00:00 sleep infinity
root         6     0  0 13:45 pts/0    00:00:00 bash
root        16     1  0 13:46 pts/0    00:00:00 [sleep] <defunct>
root        19     6  0 13:47 pts/0    00:00:00 ps -ef
{% endhighlight %}
<figure>
<figcaption class="caption">[Shell 5] Container Orphan, Zombie Process in Container </figcaption>
</figure>

Container의 Orphan Process 또한 Container의 PID 1번인 Process인 Container Init Process에 의해서 거두어 진다. [Shell 5]는 Container 내부에서 Orphan Process 생성 및 Zombie Process 생성 과정을 나타내고 있다. [Shell 5]에서 Ubuntu Container의 Init Process는 sleep infinity Process로 설정하였다. 그 후 Ubuntu Container에 bash Process를 생성하여 sleep 60 Process를 Orphan Process로 만들었다. sleep 60 Process의 Parant는 sleep inifinity가 되는것을 확인할 수 있다. sleep infinity Process는 죽은 Child Process를 정리하는 기능을 수행하지 못하기 때문에, 60초 후에 sleep 60 Process는 Zombie Process가 된다.

{% highlight console %}
# Check sleep zombie process in the host
(host)# ps -ef
root     12552 12526  0 22:33 ?        00:00:00 sleep infinity
root     18319 12526  0 22:45 pts/0    00:00:00 bash
root     18461 12552  0 22:46 pts/0    00:00:00 [sleep] <defunct>
root     20908 28207  0 22:51 pts/24   00:00:00 ps -ef

# After remove ubuntu container, sleep zombie process disappears
(host)# docker rm -f ubuntu
(host)# ps -ef
root     22783 28207  0 22:55 pts/24   00:00:00 ps -ef
{% endhighlight %}
<figure>
<figcaption class="caption">[Shell 6] Container Orphan, Zombie Process in Host </figcaption>
</figure>

Container의 Zombie Process는 Host Process에서도 확인할 수 있다. Container Zombie Process는 Container가 지워져야 사라진다. [Shell 6]은 Host에서 Container의 Zombie Process를 확인하고, Container의 제거를 통해서 Container의 Zombie Process를 지우는 과정을 나타내고 있다. Container의 Zombie Process를 방지하기 위해서는 Container의 Init Process가 죽은 Child Process를 완전히 정리하는 역활을 수행해야 한다. Container의 Init Process로 이용되는 supervisord, dumb-init, tini 등은 Child Process를 완전히 정리하여 Zombie Process를 방지하는 기능을 수행한다.

![[그림 2] Orphan, Zombie Process]({{site.baseurl}}/images/onebyone_container/PID_Namespace/Orphan_Zombie_Process.PNG){: width="600px"}

[그림 2]에서 A Namespace 및 파랑 숫자 Host에서의 Orphan Process의 처리과정을 나타내고 있다. B Process가 죽은뒤 D, E Process는 Orphan Process가 되고 Host의 Init Process인 A Process가 새로운 Parent가 된다. 따라서 D Process가 죽은뒤에는 A Process가 D Process를 정리한다.

[그림 2]에서 B Namespace 및 빨간 숫자는 Container에서의 Orphan, Zombie Process의 처리과정을 나타내고 있다. F Process가 죽은뒤에 G, H Process는 Orphan Process가 되고 Container의 Init Process인 C Process가 새로운 Parent가 된다. 따라서 G Process가 죽은뒤에는 C Process는 G Process를 정리해야 한다. 만약 C Process가 G Process를 정리하지 못한다면 G Process는 Zombie Process가 된다. Container가 정지하면 C Process는 죽게되며 G, H Process는 다시 Orphan Process가 되어 A Process가 새로운 부모 Process가 된다.