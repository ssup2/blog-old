---
title: 3.1. PID Namespace
category: 하나씩 익히는 Container
date: 2020-04-12T12:00:00Z
lastmod: 2020-04-12T12:00:00Z
comment: true
adsense: true
---

{% highlight console %}
# Run a nginx container and exec bash in the nginx container
(host)# docker run -d --rm --name nginx nginx:1.16.1
(host)# docker exec -it nginx bash

# Check process in the nginx container
(nginx)# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Apr10 ?        00:00:00 nginx: master process nginx -g daemon off;
nginx        6     1  0 Apr10 ?        00:00:00 nginx: worker process
{% endhighlight %}
<figure>
<figcaption class="caption">[Shell 1] nginx Container Process</figcaption>
</figure>

{% highlight console %}
# Run a httpd container and exec bash in the httpd container
(host)# docker run -d --rm --name httpd httpd:2.4.43
(host)# docker exec -it httpd bash

# Check process in the httpd container
(httpd)# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Apr10 ?        00:00:05 httpd -DFOREGROUND
daemon       7     1  0 Apr10 ?        00:00:00 httpd -DFOREGROUND
daemon       8     1  0 Apr10 ?        00:00:00 httpd -DFOREGROUND
daemon       9     1  0 Apr10 ?        00:00:00 httpd -DFOREGROUND
{% endhighlight %}
<figure>
<figcaption class="caption">[Shell 2] httpd Container Process</figcaption>
</figure>

{% highlight console %}
# Check process in the host
(host)# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
...
root     20997 20969  0 Apr10 ?        00:00:00 nginx: master process nginx -g daemon off;
systemd+ 21042 20997  0 Apr10 ?        00:00:00 nginx: worker process
...
root     25759 25739  0 Apr10 ?        00:00:05 httpd -DFOREGROUND
daemon   25816 25759  0 Apr10 ?        00:00:00 httpd -DFOREGROUND
daemon   25817 25759  0 Apr10 ?        00:00:00 httpd -DFOREGROUND
daemon   25818 25759  0 Apr10 ?        00:00:00 httpd -DFOREGROUND
...
{% endhighlight %}
<figure>
<figcaption class="caption">[Shell 3] Host Process</figcaption>
</figure>

Process Isolation을 담당하는 PID Namespace를 알아본다. [Shell 1]은 nginx Container 내부에서 본 Process를 나타내고 있고 [Shell 2]는 httpd Container 내부에서 본 Process를 나타내고 있다. 마지막으로 [Shell 3]은 Host에서 본 Process를 나타내고 있다. NGNIX Container와 httpd Container는 서로의 Process를 확인할 수 없지만, Host는 두 Container의 Proces를 모두 확인할 수 있다. 이러한 현상은 PID Namespace 때문에 발생한다.

![[그림 1] PID Namespace]({{site.baseurl}}/images/onebyone_container/PID_Namespace/PID_Namespace.PNG)

PID Namespace는 의미 그대로 PID를 격리하는 역활을 수행하는 Namespace이다. [그림 1]은 PID Namespace와 Process Tree의 관계를 나타내고 있다. [그림 1]에는 A,B,C,D 4개의 PID Namespace가 존재한다. PID Namespace는 Namespace중에서 유일하게 **"계층"**을 갖는 Namespace이다. 가장 높은 PID Namespace는 **"Init PID Namespace"**라고 명칭한다. [그림 1]의 왼쪽 Tree는 PID Namespace의 계층을 나타내고 있다. A Namespace는 Init Namespace이며 자식 Namespace로 B, C Namespace를 갖고 있다.

각 Namespace에서 Process Tree의 가장 높이 위치하는 Proess는 **"Init Process"**라고 명칭한다. [그림 1]에서 A Process는 A Namespace의 Init Process이고, D Process는 C Namespace의 Init Process이다. 각 PID Namespace가 볼 수 있는 Process는 PID Namespace의 Init Process의 하위 Process만 접근할 수 있다. [그림 1]에서 C Namespace의 Init Process는 D Process이기 때문에 C Namespace는 D Process의 하위 Process에만 접근할 수 있다. 이러한 특징 때문에 형제 관계를 갖는 PID Namespace들은 서로의 Proces를 접근할 수 없다. [그림 1]에서 B Namespace와 C Namespace는 서로의 Process를 접근할 수 없다.

동일한 Process라도 각 Namespace마다 다른 PID를 갖는다. 또한 각 Namespace를 Init Procesess는 해당 Namespace에서 1번 PID를 갖는다. [그림 1]에서 E Process는 A Namespace에서는 5번 PID로 보이지만 B Namespace에서는 6번 PID로 보인다. B Process는 B Namespace의 Init Process이기 때문에 1번 B Namespace에서는 1번 PID로 보인다.

일반적으로 각 Container는 자신의 전용 PID Namespace안에서 동작한다. Host의 Process 또한 Init PID Namespace에서 동작한다. 따라서 A Namespace를 Host PID Namespace로, B Namespace를 nginx PID Namespace로, C Namespace를 httpd PID Namespace로 Mapping 한다면 각 Container에서 보이는 Process들의 현상을 이해할 수 있게 된다.

#### 3.1.1. Orphan, Zombie Process with PID Namespace

PID Namespace와 함께 반드시 고려되어야 할 부분은 **Orphan Process**와 **Zombie Process**이다. Linux에서는 PID 1번을 갖고 있는 Init Process를 제외한 나머지 Process들은 반드시 Parent Process를 갖는다. Parent Process는 fork() System Call 호출을 통해서 Child Process인 자신을 생성한 Process를 의미한다. 따라서 Process들은 Init Process를 Root로 하는 Tree의 관계를 갖게된다 Orphan Process는 의미 그대로 Parent Prcess가 죽어 고아가된 Process를 의미하며, Linux에서 Init Process는 모든 Orphan Process를 거두어 자기 자신이 새로운 Parent Process가 된다.

Zombie Process도 의미 그대로 죽지 않는 Process를 의미한다. Zombie Process가 죽지 않는 이유는 Process는 실제로 죽어 존재하지 않지만 Process의 Meta 정보만 Kernel에 남아 있는 상태이기 때문이다. 대표적인 Process의 Meta 정보에는 PID와 Process가 종료되면서 Process의 실행 결과를 알려주는 Exit Code가 있다. 일반적으로 Process가 죽으면 죽은 Process의 Meta 정보는 Parent Process가 wait() System Call 호출을 통해서 회수하기 때문에 문제되지 않지만, Parent Process가 wait() System Call을 호출하지 않아 Meta 정보를 회수하지 않으면 죽은 Process는 Zombie Process가 된다.

![[그림 2] Orphan, Zombie Process with PID Namespace]({{site.baseurl}}/images/onebyone_container/PID_Namespace/Orphan_Zombie_Process.PNG){: width="600px"}

Linux에서 Init Process는 Orphan Process를 거두어 자기 자신이 새로운 Parent Process가 되기 때문에, Init Process는 반드시 Child Process의 Meta 정보를 회수하는 역활을 수행해야 한다. 그렇지 않으면 Zombie Process가 계속 발생하게 된다. [그림 2]에서 A Namespace는 Host의 PID Namespace를 의미하며, Host에서의 Orphan Process의 처리과정을 나타내고 있다. B Process가 죽은뒤 D, E Process는 Orphan Process가 된다. Host의 Init Process인 A Process는 D, E Process의 새로운 Parent Process가 된다. 이후 D Process가 죽은뒤에는 A Process가 D Process의 Meta 정보를 회수하여 D Process가 Zombie Process가 되는것을 막는다.

{% highlight console %}
# Run bash and run sleep in the bash
(host)# bash -c "(bash -c 'sleep 60')" &
(host)# ps -ef
root         1     0  0 Apr22 ?        00:00:03 /sbin/init
...
root     29756 28207  0 22:06 pts/24   00:00:00 bash -c (bash -c 'sleep 60')
root     29758 29756  0 22:06 pts/24   00:00:00 sleep 60
root     29764 28207  0 22:06 pts/24   00:00:00 ps -ef

# Kill bash process and check the ppid of sleep process
(host)# kill -9 29756
(host)# ps -ef
root         1     0  0 Apr22 ?        00:00:03 /sbin/init
...
root     29758     1  0 22:06 pts/24   00:00:00 sleep 60
root     29779 28207  0 22:07 pts/24   00:00:00 ps -ef

# After 60s there is no sleep process info
(host)# ps -ef
root         1     0  0 Apr22 ?        00:00:03 /sbin/init
...
root     29779 28207  0 22:07 pts/24   00:00:00 ps -ef
{% endhighlight %}
<figure>
<figcaption class="caption">[Shell 4] Host Orphan Process </figcaption>
</figure>

[Shell 4]는 Host에서 Orphan Process 생성 및 상태를 확인하는 과정을 나타내고 있다. [Shell 4]에서 sleep Process는 Bash Process를 Parent로 갖는 Process인데 Bash Process가 죽은 다음 sleep Process의 Parent는 init Process가 되는것을 확인할 수 있다. 60초 후에 sleep이 죽은 다음 /sbin/init Process는 Child Process인 sleep Process의 Meta 정보를 회수하여 sleep Process가 Zombie Process가 되는것을 방지한다.

{% highlight console %}
# Run a ubuntu container with sleep init process and exec bash in the ubuntu container
(host)# docker run -d --rm --name ubuntu ubuntu sleep infinity
(host)# docker exec -it ubuntu bash

# Run bash and run sleep in the bash
(ubuntu)# bash -c "(bash -c 'sleep 60')" &
(ubuntu)# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 13:33 ?        00:00:00 sleep infinity
root         6     0  1 13:45 pts/0    00:00:00 bash
root        15     6  0 13:46 pts/0    00:00:00 bash -c (bash -c 'sleep 60')
root        16    15  0 13:46 pts/0    00:00:00 sleep 60
root        17     6  0 13:46 pts/0    00:00:00 ps -ef

# Kill bash process to change ppid of sleep 60 process to sleep infinity process
(ubuntu)# kill -9 15
(ubuntu)# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 13:33 ?        00:00:00 sleep infinity
root         6     0  0 13:45 pts/0    00:00:00 bash
root        16     1  0 13:46 pts/0    00:00:00 sleep 60
root        18     6  0 13:46 pts/0    00:00:00 ps -ef

# After 60s sleep 60 process to be zombie process.
(ubuntu)# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 13:33 ?        00:00:00 sleep infinity
root         6     0  0 13:45 pts/0    00:00:00 bash
root        16     1  0 13:46 pts/0    00:00:00 [sleep] <defunct>
root        19     6  0 13:47 pts/0    00:00:00 ps -ef
{% endhighlight %}
<figure>
<figcaption class="caption">[Shell 5] Container Orphan, Zombie Process in Container </figcaption>
</figure>

Container에서 Orphan Process가 발생하면 Host의 Init Process가 아니라 Container Init Process가 새로운 Parent Process가 된다. [Shell 5]는 Container 내부에서 Orphan Process 생성 및 Zombie Process 생성 과정을 나타내고 있다. [Shell 5]에서 Ubuntu Container의 Init Process는 sleep infinity Process로 설정하였다. 그 후 Ubuntu Container에 bash Process를 생성하여 sleep 60 Process를 Orphan Process로 만들었다. sleep 60 Process의 Parant는 sleep inifinity가 되는것을 확인할 수 있다. sleep infinity Process는 wait() System Call 호출하지 않기 때문에 죽은 Child Process의 Meta 정보를 회수하는 기능을 수행하지 못한다. 따라서 60초 후에 sleep 60 Process는 Zombie Process가 된다.

Container의 Zombie Process를 방지하기 위해서는 Container의 Init Process가 죽은 Child Process의 Meta 정보를 회수하는 기능을 수행해야 한다. Container의 Init Process로 이용되는 supervisord, dumb-init, tini 등은 Child Process의 Meta 정보를 회수하는 기능을 갖고 있기 때문에 Container의 Init Process로 많이 이용되는 것이다.

{% highlight console %}
# Check sleep zombie process in the host
(host)# ps -ef
root     12552 12526  0 22:33 ?        00:00:00 sleep infinity
root     18319 12526  0 22:45 pts/0    00:00:00 bash
root     18461 12552  0 22:46 pts/0    00:00:00 [sleep] <defunct>
root     20908 28207  0 22:51 pts/24   00:00:00 ps -ef

# After remove ubuntu container, sleep zombie process disappears
(host)# docker rm -f ubuntu
(host)# ps -ef
root     22783 28207  0 22:55 pts/24   00:00:00 ps -ef
{% endhighlight %}
<figure>
<figcaption class="caption">[Shell 6] Container Orphan, Zombie Process in Host </figcaption>
</figure>

Container의 Zombie Process는 Host Process에서도 확인할 수 있으며, Container Zombie Process는 Container가 제거되야 사라진다. [Shell 6]은 Host에서 Container의 Zombie Process를 확인하고, Container의 제거를 통해서 Container의 Zombie Process를 제거하는 과정을 나타내고 있다. Container의 Zombie Process가 Container가 제거되면 사라지는 이유는 Container의 Orphan, Zombie Process의 처리 과정을 이해하면 알 수 있다.

[그림 2]에서 B Namespace는 Container의 PID Namespace를 의미하며, Container에서의 Orphan Process의 처리과정을 나타내고 있다. F Process가 죽은뒤에 G, H Process는 Orphan Process가 되고 Container의 Init Process인 C Process가 새로운 Parent Process가 된다. 따라서 G Process가 죽은뒤에는 C Process는 G Process의 Meta 정보를 회수해야 한다. 만약 C Process가 G Process의 Meta 정보를 회수하지 않는다면 G Process는 Zombie Process가 된다.

Container가 정지하면 C Process는 죽게되며 H Process 뿐만 아니라 Zombie Process인 G Process의 Parent Process도 A Process가 된다. A Process는 Host Init Process이기 때문에 Zombie Process인 G Process의 Meta 정보를 회수하여 G Process를 제거한다.